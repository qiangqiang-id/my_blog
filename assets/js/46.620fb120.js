(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{527:function(t,s,e){"use strict";e.r(s);var a=e(1),r=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"webpack-如何监听文件变化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack-如何监听文件变化"}},[t._v("#")]),t._v(" webpack 如何监听文件变化？")]),t._v(" "),s("p",[t._v("文件监听是在发现源码发现变化时，自动重新构建出新的输出文件\nwebpack 开启开启监听模式，有两种方式：")]),t._v(" "),s("ul",[s("li",[t._v("启动 webpack 命令，后面增加 --watch 参数")]),t._v(" "),s("li",[t._v("在配置 webpack.config.js 配置 watch:true")])]),t._v(" "),s("p",[s("strong",[t._v("缺点：")]),t._v(" 每次都需要手动刷新浏览器")]),t._v(" "),s("h4",{attrs:{id:"文件监听原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件监听原理"}},[t._v("#")]),t._v(" 文件监听原理")]),t._v(" "),s("p",[t._v("webpack 轮巡判断文件的最后编辑时间是否发生了变化，某个文件发生了变化，并不会立刻打包，而是先换存起来（其实这里就是一个防抖操作）。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("module"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("watch")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 开启watch 之后的配置")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("watchOption")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("ignored")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[t._v("node_modules")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[t._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 默认为空，不监听的文件夹或文件，支持正则。")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("aggregateTimeout")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("300")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 监听发生变化，等待300ms才执行打包，默认就是300ms")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("poll")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一秒轮巡监听的次数，1s轮巡1000次，也就是1ms轮巡一次，默认就1000。")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("h3",{attrs:{id:"热更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#热更新"}},[t._v("#")]),t._v(" 热更新")]),t._v(" "),s("img",{attrs:{src:t.$withBase("/img/engineering/webpack热更新.jpg"),alt:"webpack-热更新"}}),t._v(" "),s("ul",[s("li",[t._v("Webpack Compile：将 js 编译成 Bundle")]),t._v(" "),s("li",[t._v("HMR Server：将热更新的文件输出给 HMR Runtime")]),t._v(" "),s("li",[t._v("Bundle Server：开启本地服务器，将打包的后的 bundle 文件放置服务器内存总，供浏览器访问")]),t._v(" "),s("li",[t._v("HMR Runtime：会被注入到浏览器，更新文件的变化。")]),t._v(" "),s("li",[t._v("bundle.js：构建输出的文件")])]),t._v(" "),s("p",[s("strong",[t._v("步骤：")]),t._v("\n有两种情况")]),t._v(" "),s("ul",[s("li",[t._v("启动 webpack\n首先会经过 Webpack Compile 进行编译，将编译后的文件传输给 Bundle Server 开启本地服务，浏览器就可以通过这个服务去访问打包好的 bundle.js")]),t._v(" "),s("li",[t._v("更新文件自动打包更新\n一样的，监听到文件的更新，首先会通过 Webpack compile 进行编译，编译后的文件通过 HMR Server 通知到 HMR Runtime 更新 bundle.js 文件。HMR Server 和 HMR Runtime 之间是相互通信的，采用的协议通信协议是 Web Socket。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);