---
title: 如何理解TCP的三次握手和四次挥手？
date: 2022-5-20
categories:
  - 网络协议
tags: 网络
sidebar: 'auto'
---

**前言:**
我们都知道，http 协议是基于 TCP 协议的。因为 TCP 是面向连接的，所以在发起一个请求时，首先会进行网络连接，而连接是 TCP 所做的事情，这个连接过程就是 TCP 的**三次握手**。当请求发起，服务端并响应之后，为了不占用资源，连接会断开，这个断开过程就是 TCP 的**四次挥手**。

## TCP 状态位

- **SYN**：发起一个连接
- **ACK**：回复
- **RST**：重新连接
- **FIN**：结束连接

## TCP 状态以及描述表

| 状态         | 描述                                                                                         |
| ------------ | -------------------------------------------------------------------------------------------- |
| LISTEN       | 等待来自远程 TCP 应用程序的请求                                                              |
| SYN_SENT     | 发送连接请求后等地啊来自远程断点的确认。TCP 第一次握手后客户端所处的状态                     |
| SYN-RECEIVED | 该端点已经接收到连接请求并发送确认。该端点正在等待最终确认。TCP 第二次握手后服务端所处的状态 |
| ESTABLISHED  | 代表连接已经建立起来了。这是连接数据传输阶段的正常状态                                       |
| FIN_WAIT_1   | 等待来自远程 TCP 的终止连接请求或终止请求的确认                                              |
| FIN_WAIT_2   | 在此端点发送终止连接请求后，等待来自远程 TCP 的连接终止请求                                  |
| CLOSE_WAIT   | 该端点已经收到来自远程端点的关闭请求，此 TCP 正在等待本地应用程序的连接终止请求              |
| CLOSING      | 等待来自远程 TCP 的连接终止请求确认                                                          |
| LAST_ACK     | 等待先前发送到远程 TCP 的连接终止请求的确认                                                  |
| TIME_WAIT    | 等待足够的时间来确保远程 TCP 接收到其连接终止请求的确认                                      |

## 三次握手

**建立连接**

- A：你好，我是 A，
- B：你好 A，我是 B。
- A：你好 B

### 为啥不是两次

A 发起一个连接请求，B 收到连接请求后会回复到 A。此时假设 A 不再次回复 B 的话，会出现一下几种情况：

- A 可能不想与 B 连接
- B 回复 A 的请求可能绕路了
- A 可能已经挂了

### 为啥不是四次

握手的目的就是为了确认双方通信状态与信息。那四次握手可以吗？
当然可以，400 百次都可以，但是三次就够了，多了并无益处。

**状态图**

<img :src="$withBase('/img/network/三次握手.jpg')" width="500px" alt="三次握手" />

最开始双方处于 **CLOSE** 状态。然后服务端会监听某一个端口，进入**LISTEN**状态。 客户端会主动发起 SYN 连接，自己进入**SYN-SENY** 状态。
服务端接受到后，返回**SYN** 和 **ACK**，自己进入了**SYN-REVD**状态。之后客户端再次发送 **ACK** 给服务端，自己 进入了 **ESTABLISHED**状态；服务端收到 **ACK** 也进入了 **ESTABLISHED**状态。

## 四次挥手

**断开连接**

- A：你好 B，这边要断开了，
- B：好的 A，我知道了，
- B：你好 A，那我也断开了，拜拜，
- A：好的，拜拜

### 为啥不是三次

因为服务端接收客户端的**FIN**，不会立即返回**FIN**，需要等待服务端所有的报文都发送完毕，才能发送**FIN**。所以服务端会先发送发送一个**ACK**表示服务端已经接受到客户端的**FIN**。
如果将服务端的**ACK**和**FIN**合并的话，由于要等待服务端所有的报文发送完毕，等待的时间过长的话，客户端误以为**FIN**没有到达服务端，就会不断的重新发送**FIN**。

**状态图**

<img :src="$withBase('/img/network/四次挥手.jpg')" width="500px" alt="四次挥手" />

最开始双方都处于 **ESTABLISHED**状态。 客户端需要断开，向服务端发起一个 **FIN** 请求后，进入 **FIN_WAIT_1** 状态。服务端接受后向客户端确认**ACK**，进入了**CLOSE_WAIT**状态。客户端接收到后，进入**FIN_WAIT2**状态。随后服务器继续向客户端发送**FIN**，并进入**LAST_ACK**状态。客户端接受到服务端的**FIN**后，自己变成了**TIME_WAIT**状态，然后发送**ACK**给服务器。

**注意：** MSL 表示报文在网络上生存的最大时间，超过这个时间报文就被丢弃。这里是一来一回，所以就是等待 2MSL 时间。在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK

## 序号的作用

序号的作用就是为了解决乱序问题，不编好号怎么确认哪个应该先来，哪个应该后来呢。另外注意的是 **SYN**是需要消耗一个序列号的，回复**ACK** 的序号都要加一。所以有一个规则就是：**凡是需要对方确认的，一定消耗一个 TCP 序列号**。
